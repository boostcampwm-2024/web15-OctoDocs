name: Auto Assign, Review, and Merge

on:
    pull_request:
        types:
            - opened
            - labeled
            - unlabeled
            - review_requested
            - review_request_removed
    pull_request_review:
        types:
            - submitted

jobs:
    auto-assign:
        if: github.event_name == 'pull_request'
        runs-on: ubuntu-latest
        steps:
            - name: Checkout repository
              uses: actions/checkout@v2

            - name: Set up Node.js
              uses: actions/setup-node@v2
              with:
                  node-version: "16"

            - name: Assign PR creator as Assignee
              uses: actions/github-script@v6
              with:
                  script: |
                      const prNumber = context.payload.pull_request.number;
                      const currentAssignees = context.payload.pull_request.assignees.map(a => a.login);

                      // PR ì‘ì„±ìê°€ ì´ë¯¸ ë‹´ë‹¹ìë¡œ ì§€ì •ë˜ì–´ ìˆì§€ ì•Šì€ ê²½ìš°ì—ë§Œ í• ë‹¹
                      if (!currentAssignees.includes(context.actor)) {
                          await github.rest.issues.addAssignees({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            issue_number: prNumber,
                            assignees: [context.actor]
                          });
                      }

    auto-reviewers:
        if: github.event_name == 'pull_request'
        runs-on: ubuntu-latest
        needs: auto-assign
        steps:
            - name: Checkout repository
              uses: actions/checkout@v2

            - name: Set up Node.js
              uses: actions/setup-node@v2
              with:
                  node-version: "16"

            - name: Add reviewers based on labels
              uses: actions/github-script@v6
              with:
                  script: |
                      const prNumber = context.payload.pull_request.number;
                      const prAuthor = context.payload.pull_request.user.login;
                      const assignees = context.payload.pull_request.assignees.map(a => a.login);

                      // í˜„ì¬ ë¦¬ë·°ì–´ ëª©ë¡ ê°€ì ¸ì˜¤ê¸°
                      const currentReviewers = context.payload.pull_request.requested_reviewers
                          ? context.payload.pull_request.requested_reviewers.map(r => r.login)
                          : [];

                      const BE_reviewers = ['summersummerwhy', 'ezcolin2', 'Tolerblanc'];
                      const FE_reviewers = ['yewonJin', 'djk01281'];
                      const doc_reviewers = ['summersummerwhy', 'ezcolin2', 'Tolerblanc', 'yewonJin', 'djk01281'];

                      // Function to filter out assignees, PR author, and current reviewers
                      const filterReviewers = (reviewers) => {
                          return reviewers.filter(r => 
                              !assignees.includes(r) && 
                              r !== prAuthor && 
                              !currentReviewers.includes(r)
                          );
                      };

                      // Check the labels on the PR and assign appropriate reviewers
                      const labels = context.payload.pull_request.labels.map(label => label.name);
                      let reviewersToAdd = [];

                      if (labels.includes('ğŸ§ğŸš€ğŸ˜¶â€ğŸŒ«ï¸ BE')) {
                          reviewersToAdd.push(...filterReviewers(BE_reviewers));
                      }
                      if (labels.includes('ğŸ³ğŸ£ FE')) {
                          reviewersToAdd.push(...filterReviewers(FE_reviewers));
                      }
                      if (labels.includes('ğŸ“š Documentation')) {
                          reviewersToAdd.push(...filterReviewers(doc_reviewers));
                      }

                      // Remove duplicates and limit the number of reviewers
                      reviewersToAdd = [...new Set(reviewersToAdd)];
                      const maxReviewers = 4; // ìµœëŒ€ ë¦¬ë·°ì–´ ìˆ˜ ì œí•œ
                      reviewersToAdd = reviewersToAdd.slice(0, maxReviewers);

                      // Request reviewers only if there are new reviewers to add
                      if (reviewersToAdd.length > 0) {
                          try {
                              await github.rest.pulls.requestReviewers({
                                  owner: context.repo.owner,
                                  repo: context.repo.repo,
                                  pull_number: prNumber,
                                  reviewers: reviewersToAdd
                              });
                              console.log(`Added reviewers: ${reviewersToAdd.join(', ')}`);
                          } catch (error) {
                              console.error('Failed to add reviewers:', error);
                              // ì‹¤íŒ¨í•´ë„ ì›Œí¬í”Œë¡œìš°ëŠ” ê³„ì† ì§„í–‰
                          }
                      } else {
                          console.log('No new reviewers to add');
                      }

    auto-merge:
        if: github.event_name == 'pull_request_review' && github.event.review.state == 'approved'
        runs-on: ubuntu-latest
        permissions:
            pull-requests: write
            contents: write
        steps:
            - name: Merge and Close PR if Approved
              uses: actions/github-script@v6
              with:
                  script: |
                      const prNumber = context.payload.pull_request.number || context.payload.review.pull_request_number;

                      try {
                        // PR ì •ë³´ ê°€ì ¸ì˜¤ê¸°
                        const pr = await github.rest.pulls.get({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          pull_number: prNumber
                        });

                        if (pr.data.merged) {
                          console.log('PRì´ ì´ë¯¸ ë¨¸ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.');
                          return;
                        }

                        // ë¨¸ì§€ ê°€ëŠ¥ ìƒíƒœ í™•ì¸
                        if (!pr.data.mergeable) {
                          console.log('PRì— ì¶©ëŒì´ ìˆìŠµë‹ˆë‹¤. ìˆ˜ë™ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤.');
                          core.setFailed('PRì— ì¶©ëŒì´ ìˆì–´ ìë™ ë¨¸ì§€ë¥¼ ì§„í–‰í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.');
                          return;
                        }

                        // ëª¨ë“  ë¦¬ë·° í™•ì¸
                        const reviews = await github.rest.pulls.listReviews({
                          owner: context.repo.owner,
                          repo: context.repo.repo,
                          pull_number: prNumber
                        });

                        // ê° ë¦¬ë·°ì–´ì˜ ìµœì‹  ë¦¬ë·° ìƒíƒœë§Œ í™•ì¸
                        const latestReviews = new Map();
                        reviews.data.forEach(review => {
                          latestReviews.set(review.user.login, review.state);
                        });

                        const hasRejection = Array.from(latestReviews.values()).includes('CHANGES_REQUESTED');
                        const approvalCount = Array.from(latestReviews.values()).filter(state => state === 'APPROVED').length;

                        if (!hasRejection && approvalCount >= 1) {
                          console.log('PR ë¨¸ì§€ë¥¼ ì‹œë„í•©ë‹ˆë‹¤...');
                          await github.rest.pulls.merge({
                            owner: context.repo.owner,
                            repo: context.repo.repo,
                            pull_number: prNumber
                          });

                          // ë¸Œëœì¹˜ ì‚­ì œ
                          const branchName = pr.data.head.ref;
                          if (branchName !== 'main' && branchName !== 'master') {
                            await github.rest.git.deleteRef({
                              owner: context.repo.owner,
                              repo: context.repo.repo,
                              ref: `heads/${branchName}`
                            });
                          }
                        } else {
                          console.log('ë¨¸ì§€ ì¡°ê±´ì´ ì¶©ì¡±ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.');
                        }
                      } catch (error) {
                        console.error('Error:', error);
                        core.setFailed(error.message);
                      }
